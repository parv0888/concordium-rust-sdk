initSidebarItems({"constant":[["ACCOUNT_ADDRESS_SIZE","Size of an account address when serialized in binary. NB: This is different from the Base58 representation."]],"derive":[["Deserial","Derive the Deserial trait. See the documentation of `derive(Serial)` for details and limitations."],["Serial","Derive the Serial trait for the type."],["Serialize","A helper macro to derive both the Serial and Deserial traits. `[derive(Serialize)]` is equivalent to `[derive(Serial, Deserial)]`, see documentation of the latter two for details and options: `derive(Serial)`, `derive(Deserial)`."]],"enum":[["AccountAddressParseError","Error type for when parsing an account address."],["Address","Either an address of an account, or contract."],["AddressParseError","Error that can occur when parsing an [`Address`] from a string."],["AmountParseError","An error indicating why parsing of an amount failed. Since amount parsing is typically a user-facing activity this is fairly precise, so we can notify the user why we failed, and what they can do to fix it."],["ContractAddressParseError","Error that can occur when parsing a [`ContractAddress`] from a string."],["ExchangeRateConversionError","An error that may occur when converting from a string to an exchange rate."],["ExchangeRateJSON",""],["NewAttributeValueError","Errors that can occur when constructing a new [`AttributeValue`]."],["NewContractNameError",""],["NewReceiveNameError",""],["ParseDurationError",""],["ParseTimestampError",""],["SeekFrom","This is essentially equivalent to the SeekFrom type from the rust standard library, but reproduced here to avoid dependency on `std::io`, as well as to use 32-bit integers to specify positions. This saves some computation and space, and is adequate for the kind of data sizes that are possible in smart contracts."]],"fn":[["deserial_hashmap_no_length","Read a HashMap as a list of key-value pairs given some length."],["deserial_hashset_no_length","Read a HashSet as a list of keys, given some length. NB: This ensures there are no duplicates."],["deserial_map_no_length","Read a BTreeMap as a list of key-value pairs given some length. NB: This ensures there are no duplicates, hence the specialized type. Moreover this will only succeed if keys are listed in order."],["deserial_map_no_length_no_order_check","Read a BTreeMap as a list of key-value pairs given some length. Slightly faster version of `deserial_map_no_length` as it is skipping the order checking"],["deserial_set_no_length","Read a BTreeSet as a list of keys, given some length. NB: This ensures there are no duplicates, hence the specialized type. Moreover this will only succeed if keys are listed in order."],["deserial_set_no_length_no_order_check","Read a BTreeSet as an list of key-value pairs given some length. Slightly faster version of `deserial_set_no_length` as it is skipping the order checking. The only check that is made to the set is that there are no duplicates."],["deserial_vector_no_length","Read a vector given a length."],["from_bytes","Dual to `to_bytes`."],["is_valid_entrypoint_name","Check whether the given string is a valid contract entrypoint name. This is the case if and only if"],["serial_hashmap_no_length","Write a HashMap as a list of key-value pairs in to particular order, without the length information."],["serial_hashset_no_length","Write a HashSet as a list of keys in no particular order, without the length information."],["serial_map_no_length","Write a Map as a list of key-value pairs ordered by the key, without the length information."],["serial_set_no_length","Write a BTreeSet as an ascending list of keys, without the length information."],["serial_vector_no_length","Write a slice of elements, without including length information. This is intended to be used either when the length is statically known, or when the length is serialized independently as part of a bigger structure."],["to_bytes","Serialize the given value to a freshly allocated vector of bytes using the provided `Serial` instance."]],"mod":[["attributes","Currently defined attributes possible in a policy."],["constants",""],["schema","Types related to contract schemas. These are optional annotations in modules that allow the users of smart contracts to interact with them in a way that is better than constructing raw bytes as parameters."],["schema_json",""]],"struct":[["AccountAddress","Address of an account, as raw bytes."],["Amount","The type of amounts on the chain"],["AttributeTag","Tag of an attribute. See the module attributes for the currently supported attributes."],["AttributeValue","An attribute value. The meaning of the bytes is dependent on the type of the attribute."],["ChainMetadata","Chain metadata accessible to both receive and init methods."],["ContractAddress","Address of a contract."],["ContractName","A contract name. Expected format: “init_<contract_name>”."],["Cursor","Add offset tracking inside a data structure."],["Duration","Duration of time in milliseconds."],["EntrypointName","An entrypoint name (borrowed version). Expected format: “<func_name>” where the name of the function consists solely of ASCII alphanumeric or punctuation characters."],["ExchangeRate","An exchange rate between two quantities. This is never 0, and the exchange rate should also never be infinite."],["ModuleReference","A reference to a smart contract module deployed on the chain."],["OwnedContractName","A contract name (owned version). Expected format: “init_<contract_name>”."],["OwnedEntrypointName","An entrypoint name (owned version). Expected format: “<func_name>”. Most methods on this type are available via the `as_entrypoint_name` and the methods on the [`EntrypointName`] type."],["OwnedParameter","Parameter to the init function or entrypoint. Owned version."],["OwnedReceiveName","A receive name (owned version). Expected format: “<contract_name>.<func_name>”. Most methods are available only on the [`ReceiveName`] type, the intention is to access those via the `as_receive_name` method."],["Parameter","Parameter to the init function or entrypoint."],["ParseError","Zero-sized type to represent an error when reading bytes and deserializing."],["Policy","Policy on the credential of the account."],["ReceiveName","A receive name. Expected format: “<contract_name>.<func_name>”."],["Timestamp","Timestamp represented as milliseconds since unix epoch."]],"trait":[["Deserial","The `Deserial` trait provides a means of reading structures from byte-sources (`Read`)."],["DeserialCtx","The `DeserialCtx` trait provides a means of reading structures from byte-sources (`Read`) using contextual information. The contextual information is:"],["Get","A more convenient wrapper around `Deserial` that makes it easier to write deserialization code. It has a blanked implementation for any read and serialize pair. The key idea is that the type to deserialize is inferred from the context, enabling one to write, for example,"],["HasSize","The `HasSize` trait provides a function for getting the current byte size."],["Read","The `Read` trait provides a means of reading from byte streams."],["Seek","The `Seek` trait provides a cursor which can be moved within a stream of bytes. This is essentially a copy of std::io::Seek, but avoiding its dependency on `std::io::Error`, and the associated code size increase. Additionally, the positions are expressed in terms of 32-bit integers since this is adequate for the sizes of data in smart contracts."],["Serial","The `Serial` trait provides a means of writing structures into byte-sinks (`Write`)."],["SerialCtx","The `SerialCtx` trait provides a means of writing structures into byte-sinks (`Write`) using contextual information. The contextual information is:"],["Serialize","The `Serialize` trait provides a means of writing structures into byte-sinks (`Write`) or reading structures from byte sources (`Read`)."],["Write","The `Write` trait provides functionality for writing to byte streams."]],"type":[["ContractIndex","Contract address index. A contract address consists of an index and a subindex. This type is for the index."],["ContractSubIndex","Contract address subindex. A contract address consists of an index and a subindex. This type is for the subindex."],["HashMap","Reexport of the `HashMap` from `hashbrown` with the default hasher set to the `fnv` hash function."],["HashSet","Reexport of the `HashSet` from `hashbrown` with the default hasher set to the `fnv` hash function."],["IdentityProvider","Index of the identity provider on the chain. An identity provider with the given index will not be replaced, so this is a stable identifier."],["OwnedPolicy","A policy with a vector of attributes, fully allocated and owned. This is in contrast to a policy which is lazily read from a read source. The latter is useful for efficiency, this type is more useful for testing since the values are easier to construct."],["ParseResult","A type alias used to indicate that the value is a result of parsing from binary via the `Serial` instance."],["SlotTime","Time at the beginning of the current slot, in miliseconds since unix epoch."]]});