initSidebarItems({"constant":[["BASE_ACTION_COST","Base cost of any action. With this cost there can be at most 3_000_000 actions produced in a block (with 3_000_000NRG maximum). A memory representation of a single action is 16 bytes, which would lead to 48MB memory being used temporarily for the buffer."],["BASE_SEND_ACTION_COST","Base cost of a send action. There is more data and it also requires allocations which are a significant cost. The fixed amount of data is 72 bytes."],["BASE_SIMPLE_TRANSFER_ACTION_COST","Base cost of a simple_transfer action. There is more data (40 bytes) and it also requires allocations which are a significant cost."],["BASE_STATE_COST","Cost of accessing the instance state."],["DELETE_ITERATOR_BASE_COST","Basic administrative cost that is charged when an invalid iterator is attempted to be deleted."],["ENTRY_SIZE_COST","Cost of querying entry size."],["INVOKE_BASE_COST","Cost of the invoke action. This is just the base cost to cover administrative costs of an invoke. Specific costs of the action are charged later by the scheduler."],["ITERATOR_KEY_SIZE_COST","Cost of return the size of the iterator key. This is constant since the iterator key is readily available."],["ITERATOR_NEXT_COST","Basic administrative cost of advancing an iterator."],["LOG_EVENT_BASE_COST","Base cost of a log event call."],["MAX_ACTIVATION_FRAMES","Maximum number of nested function calls."],["MAX_CONTRACT_STATE","Maximum size of a V0 contract state in bytes."],["MAX_ENTRY_SIZE","Maximum size (in bytes) of data in the entry. The execution engine relies on this being strictly less than [u32::MAX]. Realistically this is much above any bound implied by energy, however it is good to have it explicit since correctness of the implementation relies on this."],["MAX_KEY_SIZE","Maximum size of a key in V1 contract state. The execution engine relies on this being strictly less than [u32::MAX]. Realistically this is much above any bound implied by energy, however it is good to have it explicit since correctness of the implementation relies on this."],["MAX_LOG_SIZE","Maximum size of a log message."],["MAX_NUM_LOGS","Maximum number of log messages per execution in protocol version 4 and lower. This, together with the previous constant, limits the amount of data that can be logged to 16kB."],["MEMORY_COST_FACTOR","Cost of allocation of one page of memory in relation to execution cost. FIXME: It is unclear whether this is really necessary with the hard limit we have on memory use. If we keep it, the cost must be analyzed and put into perspective"],["RESIZE_ENTRY_BASE_COST","Base cost of resizing an entry. This accounts for lookup of the entry. When the entry is resized to a larger value there is additional cost charged based on how much extra memory there is."],["TREE_TRAVERSAL_STEP_COST","Step cost of a tree traversal when invalidating entries when deleting a prefix, as well as when advancing an iterator."],["VERIFY_ECDSA_SECP256K1_COST","Cost of verification of an ecdsa over secp256k1 with the bitcoin-core implementation. Since signature verification only works on 32 byte messages (which are meant to be hashes) the cost is constant."]],"fn":[["action_send_cost","Cost of a “send” action. `x` is the size of the parameter in bytes."],["additional_entry_size_cost","Cost of allocating additional data in the entry. The argument is the number of additional bytes. This is needed since we do allocate memory on entry_resize. As a result we must bound how much can be allocated. With `100` we have at most 30MB of memory allocated with 3000000NRG. We can relax this a bit, but not much."],["additional_output_size_cost","Cost of adding an additional byte to the output. With the factor of 30 and 3000000NRG there can be at most 100MB of output produced."],["additional_state_size_cost","Cost of allocating additional smart contract state. The argument is the number of additional bytes. The `/100` guarantees that with 3_000_000NRG we can produce at most 30MB additional contract state per block."],["copy_from_host_cost","Cost of copying the given amount of bytes from the host (e.g., policy or contract state) to the Wasm memory. The 10 is to account for copying empty buffers and is based on benchmarks."],["copy_parameter_cost","Cost of copying a V1 parameter between the Wasm memory and the host in either direction."],["copy_to_host_cost","Cost of copying the given amount of bytes to the host (e.g., contract state) from the Wasm to host memory. The 10 is to account for copying empty buffers and is based on benchmarks."],["create_entry_cost","Cost of creating an entry in the instance state."],["delete_entry_cost","Cost of deleting an entry based on key length. This involves lookup in the “locked” map so it is relatively expensive."],["delete_iterator_cost","Delete an iterator. Since we need to unlock the region locked by it this cost is based on the length of the key. The exact factor of 32 is estimated based on benchmarks."],["delete_prefix_find_cost","Cost of delete_prefix which accounts for finding the prefix. It is parametrized by the length of the key."],["hash_keccak_256_cost","Cost of computing a Keccak-256 digest of the message of the given length."],["hash_sha2_256_cost","Cost of computing a SHA2-256 digest of the message of the given length."],["hash_sha3_256_cost","Cost of computing a SHA3-256 digest of the message of the given length."],["log_event_cost","Cost of logging an event of a given size."],["lookup_entry_cost","Cost of looking up an entry in the instance state. Compared to creating an entry this does not require extra storage for the key. The only cost is tree traversal and storing an indirection, which is 8 bytes. With this cost we limit the amount of extra storage that is needed. For each entry lookup we allocate a new pointer indirection. Which is 8 bytes. With these costs we limit the amount of memory needed to store these indirections to 300MB for 3_000_000NRG (with current conversion rates of NRG to InterpreterEnergy)."],["new_iterator_cost","Cost of a new iterator. This accounts for tree traversal as well as the storage the execution engine needs to keep for the iterator. When looking up an iterator we construct a structure that keeps track of the current position in the tree. This iterator is constructed for any key, including the empty key. Hence the base cost of 80 is there to ensure we don’t run out of memory. It limits memory use to around 300MB in the worst case."],["read_entry_cost","Cost of copying the given amount of bytes from the host (e.g., parameter or contract state) to the Wasm memory."],["traverse_key_cost","Cost of traversing a key in the instance state."],["verify_ed25519_cost","Cost of verification of an ed25519 with the Zebra implementation. The cost depends on the size of the message and is based on benchmarking."],["write_entry_cost","Cost of copying the given amount of bytes to the host (e.g., parameter or contract state) from the Wasm to host memory."],["write_output_cost","Cost of writing the given bytes of the return value."]]});