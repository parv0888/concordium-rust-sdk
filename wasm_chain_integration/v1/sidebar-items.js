initSidebarItems({"constant":[["MAX_EXPORT_NAME_LEN","Maximum length, in bytes, of an export function name."]],"enum":[["CommonFunc","An enumeration of functions that can be used both by init and receive methods."],["ImportFunc","Enumeration of allowed imports."],["InitOnlyFunc","An enumeration of functions that can be used only by init methods."],["InitResult",""],["Interrupt","Interrupt triggered by the smart contract to execute an instruction on the host, either an account transfer or a smart contract call."],["InvokeFailure","The kind of errors that may occur during handling of contract invoke."],["InvokeResponse","Response from an invoke call."],["ReceiveOnlyFunc","An enumeration of functions that can be used only by receive methods."],["ReceiveResult","Result of execution of a receive function."]],"fn":[["invoke_init","Invokes an init-function from a given artifact"],["invoke_init_from_artifact","Invokes an init-function from a given artifact bytes"],["invoke_init_from_source","Invokes an init-function from Wasm module bytes"],["invoke_init_with_metering_from_source","Same as `invoke_init_from_source`, except that the module has cost accounting instructions inserted before the init function is called."],["invoke_receive","Invokes an receive-function from a given artifact"],["invoke_receive_from_artifact","Invokes an receive-function from a given artifact bytes"],["invoke_receive_from_source","Invokes an receive-function from Wasm module bytes"],["invoke_receive_with_metering_from_source","Invokes an receive-function from Wasm module bytes, injects the module with metering."],["resume_receive","Resume execution of the receive method after handling the interrupt. The arguments"]],"mod":[["trie","Implementation of the contract state trie that is exposed as a key-value store to smart contracts."]],"struct":[["ConcordiumAllowedImports",""],["InitHost","A host implementation that provides access to host information needed for execution of contract initialization functions. The “host” in this context refers to the Wasm concept of a host. This keeps track of the current state and logs, gives access to the context, and makes sure that execution stays within resource bounds dictated by allocated energy."],["InstanceState","The runtime representation of the contract state. This collects all the pieces of data needed to efficiently use the state."],["InstanceStateEntry","first bit is ignored, the next 31 indicate a generation, the final 32 indicates an index in the entry_mapping."],["ProcessedImports",""],["ReceiveContext",""],["ReceiveHost","A host implementation that provides access to host information needed for execution of contract receive methods. The “host” in this context refers to the Wasm concept of a host. This keeps track of the current state and logs, gives access to the context, and makes sure that execution stays within resource bounds dictated by allocated energy."],["SavedHost","Host that is saved between handling of operations. This contains sufficient information to resume execution once control returns to the contract."],["StateLessReceiveHost","Part of the receive host that is stored to handle the interrupt. This part is not changed during the handling of the interrupt, however before execution resumes, after returning from handling of the interrupt, the logs and parameters are set appropriately."]],"trait":[["HasReceiveContext","A receive context for V1 contracts."]],"type":[["InstanceCounter","A counter of the “state instance”. When contract execution is interrupted and then resumed, if the state has been modified by the handling of the operation then all state entries that were handed out before the interrupt are invalidated. This is achieved by incrementing the instance counter."],["ParameterRef","Parameter whose ownership is tracked statically."],["ParameterVec","Parameter whose ownership is tracked dynamically. This is needed, for example, when execution passes through Haskell and Rust. Ideally this would be Arc<[u8]> but then this cannot be passed via the FFI boundary directly since [u8] is not Sized. To avoid a third type we settle on Vec."],["ReceiveInterruptedState","State of the suspended execution of the receive function. This retains both the module that is executed, as well the host."],["ReturnValue",""],["StateResult",""]]});