initSidebarItems({"enum":[["AccountTransactionEffects","Effects of an account transactions. All variants apart from [AccountTransactionEffects::None] correspond to a unique transaction that was successful."],["Address","Either an account or contract address. Some operations are allowed on both types of items, hence the need for this type."],["BakerPendingChange","Pending change in the baker’s stake."],["BlockItemSummaryDetails","Details of a block item summary, split by the kind of block item it is for."],["ContractTraceElement","A successful contract invocation produces a sequence of effects on smart contracts and possibly accounts (if any contract transfers CCD to an account)."],["CredentialType","Enumeration of the types of credentials."],["Level1Update","An update with level 1 keys of either level 1 or level 2 keys. Each of the updates must be a separate transaction."],["ProtocolVersion","An enumeration of the supported versions of the consensus protocol. Binary and JSON serializations are as Word64 corresponding to the protocol number."],["RejectReason","A reason for why a transaction was rejected. Rejected means included in a block, but the desired action was not achieved. The only effect of a rejected transaction is payment."],["RootUpdate","An update with root keys of some other set of governance keys, or the root keys themselves. Each update is a separate transaction."],["SpecialTransactionOutcome","In addition to the user initiated transactions the protocol generates some events which are deemed “Special outcomes”. These are rewards for running the consensus and finalization protocols."],["TransactionStatus","Status of a transaction known to the node."],["TransactionStatusInBlock","Status of a transaction in a given block. NB: If the transaction is committed or finalized, but not in the given block, then the API response will be `QueryError::NotFound`, hence those cases are not covered by this type."],["TransactionType","Types of account transactions."],["UpdatePayload","The type of an update payload."]],"mod":[["hashes","Different types of hashes based on SHA256."],["network","Network related types."],["queries","Types that appear in various queries of the node."],["smart_contracts","Types related to smart contracts."],["transactions","Definition of transactions and other transaction-like messages, together with their serialization, signing, and similar auxiliary methods."]],"struct":[["AbsoluteBlockHeight","Height of a block since chain genesis."],["AccessStructure","And access structure for performing chain updates. The access structure is only meaningful in the context of a list of update keys to which the indices refer to."],["AccountBaker","Information about a baker."],["AccountCreationDetails","Details of an account creation. These transactions are free, and we only ever get a response for them if the account is created, hence no failure cases."],["AccountEncryptedAmount","The state of the encrypted balance of an account."],["AccountIndex","Index of the account in the account table. These are assigned sequentially in the order of creation of accounts. The first account has index 0."],["AccountInfo","Account information exposed via the node’s API. This is always the state of an account in a specific block."],["AccountReleaseSchedule","State of the account’s release schedule. This is the balance of the account that is owned by the account, but cannot be used until the release point."],["AccountThreshold","The minimum number of credentials that need to sign any transaction coming from an associated account."],["AccountTransactionDetails","Details of an account transaction. This always has a sender and is paid for, and it might have some other effects on the state of the chain."],["Authorizations","Access structures for each of the different possible chain updates, togehter with the context giving all the possible keys."],["BakerAddedEvent",""],["BakerAggregationSignKey","FIXME: Move higher up in the dependency"],["BakerAggregationVerifyKey","FIXME: Move higher up in the dependency"],["BakerCredentials","Baker credentials type, which can be serialized to JSON and used by a concordium-node for baking."],["BakerElectionSignKey","FIXME: Move higher up in the dependency"],["BakerElectionVerifyKey","FIXME: Move higher up in the dependency"],["BakerId","Internal short id of the baker."],["BakerKeyPairs","Baker keys containing both public and secret keys. This is used to construct `BakerKeysPayload` for adding and updating baker keys. It is also used to build the `BakerCredentials` required to have a concordium node running as a baker."],["BakerKeysEvent","Result of a successful change of baker keys."],["BakerSignatureSignKey","FIXME: Move higher up in the dependency"],["BakerSignatureVerifyKey","FIXME: Move higher up in the dependency"],["BakerStakeUpdatedData","Data contained in the transaction response in case a baker stake was updated (either increased or decreased.)"],["BirkBaker","State of an individual baker."],["BirkParameters","The state of consensus parameters, and allowed participants (i.e., bakers)."],["BlockHeight","Height of a block. Last genesis block is at height 0, a child of a block at height n is at height n+1. This height counts from the last protocol update."],["BlockItemSummary","Summary of the outcome of a block item in structured form. The summary determines which transaction type it was."],["BlockSummary","Summary of transactions, protocol generated transfers, and chain parameters in a given block."],["ChainParameters","Values of chain parameters that can be updated via chain updates."],["ContractAddress",""],["ContractIndex","Contract index. The default implementation produces contract index 0."],["ContractInitializedEvent",""],["ContractSubIndex","Contract subindex. The default implementation produces contract index 0."],["CredentialRegistrationID","FIXME: Move to somewhere else in the dependency. This belongs to rust-src."],["CredentialsPerBlockLimit",""],["ElectionDifficulty",""],["EncryptedAmountRemovedEvent","Event generated when one or more encrypted amounts are consumed from the account."],["EncryptedSelfAmountAddedEvent",""],["Energy","Energy measure."],["Epoch","Epoch number"],["ExchangeRate",""],["FinalizationIndex","Sequential index of finalization. Index of the account in the account table. These are assigned sequentially in the order of creation of accounts. The first account has index 0."],["FinalizationSummary","Summary of the finalization record in a block, if any."],["FinalizationSummaryParty","Details of a party in a finalization."],["GASRewards","The reward fractions related to the gas account and inclusion of special transactions."],["GenesisIndex","Type indicating the index of a (re)genesis block. The initial genesis block has index `0` and each subsequent regenesis has an incrementally higher index."],["HigherLevelAccessStructure","Either root, level1, or level 2 access structure. They all have the same structure, keys and a threshold. The phantom type parameter is used for added type safety to distinguish different access structures in different contexts."],["InstanceUpdatedEvent","Data generated as part of updating a single contract instance. In general a single Update transaction will generate one or more of these events, together with possibly some transfers."],["Memo","A data that was registered on the chain."],["MintDistribution",""],["MintRate",""],["NewEncryptedAmountEvent","Event generated when an account receives a new encrypted amount."],["Nonce",""],["PartsPerHundredThousands",""],["PeerStatsResponse",""],["PendingUpdates",""],["ProtocolUpdate","A generic protocol update. This is essentially an announcement of the update. The details of the update will be communicated in some off-chain way, and bakers will need to update their node software to support the update."],["RegisteredData","A data that was registered on the chain."],["Release","An individual release of a locked balance."],["RewardFraction",""],["RewardParameters","Values of reward parameters."],["RewardsOverview","Current balance statistics."],["ScheduledUpdate","A scheduled update of a given type."],["Slot","Slot number"],["SlotDuration","Duration of a slot in milliseconds."],["TooBig","An error used to signal that an object was too big to be converted."],["TooLargeError","Registered data is too large."],["TransactionFeeDistribution","Update the transaction fee distribution to the specified value."],["TransactionIndex","Position of the transaction in a block."],["UnknownProtocolVersion","A structure to represent conversion errors when converting integers to protocol versions."],["UpdateDetails","Details of an update instruction. These are free, and we only ever get a response for them if the update is successfully enqueued, hence no failure cases."],["UpdateKeysCollection","The current collection of keys allowd to do updates."],["UpdateKeysIndex",""],["UpdateKeysThreshold",""],["UpdatePublicKey","A single public key that can sign updates."],["UpdateQueue","A queue of updates of a given type."],["UpdateSequenceNumber","Equivalent of a transaction nonce but for update instructions. Update sequence numbers are per update type."],["Updates","State of updates. This includes current values of parameters as well as any scheduled updates."]],"type":[["AggregateSigPairing",""]]});