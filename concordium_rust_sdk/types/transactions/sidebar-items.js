initSidebarItems({"enum":[["AddBakerKeysMarker","Marker for `BakerKeysPayload` indicating the proofs contained in `BakerKeysPayload` have been generated for an `AddBaker` transaction."],["BlockItem","A block item are data items that are transmitted on the network either as separate messages, or as part of blocks. They are the only user-generated (as opposed to protocol-generated) message."],["ConfigureBakerKeysMarker","Marker for `ConfigureBakerKeysPayload` indicating the proofs contained in `ConfigureBaker` have been generated for an `ConfigureBaker` transaction."],["Level1Update","An update with level 1 keys of either level 1 or level 2 keys. Each of the updates must be a separate transaction."],["Payload","Payload of an account transaction."],["RootUpdate","An update with root keys of some other set of governance keys, or the root keys themselves. Each update is a separate transaction."],["TransactionType","Types of account transactions."],["UpdateBakerKeysMarker","Marker for `BakerKeysPayload` indicating the proofs contained in `BakerKeysPayload` have been generated for an `UpdateBakerKeys` transaction."],["UpdatePayload","The type of an update payload."],["UpdateType","Enumeration of the types of updates that are possible."]],"fn":[["compute_transaction_sign_hash","Compute the transaction sign hash from an encoded payload and header."],["get_encoded_payload","Parse an encoded payload of specified length."],["sign_transaction","Sign the header and payload, construct the transaction, and return it."],["verify_signature_transaction_sign_hash","Verify a signature on the transaction sign hash. This is a low-level operation that is useful to avoid recomputing the transaction hash."]],"mod":[["construct","High level wrappers for making transactions with minimal user input. These wrappers handle encoding, setting energy costs when those are fixed for transaction. See also the [send] module above which combines construction with signing."],["cost","Energy costs of transactions."],["send","High level wrappers for making transactions with minimal user input. These wrappers handle encoding, setting energy costs when those are fixed for transaction."],["update","A module that provides helpers for constructing and signing update instructions."]],"struct":[["AccessStructure","And access structure for performing chain updates. The access structure is only meaningful in the context of a list of update keys to which the indices refer to."],["AccountAccessStructure","The most straighforward account access structure is a map of public keys with the account threshold."],["AccountTransaction","An account transaction signed and paid for by a sender account. The payload type is a generic parameter to support two kinds of payloads, a fully deserialized [Payload] type, and an [EncodedPayload]. The latter is useful since deserialization of some types of payloads is expensive. It is thus useful to delay deserialization until after we have checked signatures and the sender account information."],["AddBakerPayload","Payload of the `AddBaker` transaction. This transaction registers the account as a baker."],["AuthorizationsV0","Access structures for each of the different possible chain updates, togehter with the context giving all the possible keys."],["AuthorizationsV1","Access structures for each of the different possible chain updates, togehter with the context giving all the possible keys."],["BakerKeysPayload","Auxiliary type that contains public keys and proof of ownership of those keys. This is used in the `AddBaker` and `UpdateBakerKeys` transaction types. The proofs are either constructed for `AddBaker` or `UpdateBakerKeys` and the generic `V` is used as a marker to distinguish this in the type. See the markers: `AddBakerKeysMarker` and `UpdateBakerKeysMarker`."],["BakerParameters","Parameters related to becoming a baker that apply to protocol versions 1-3."],["ConfigureBakerPayload","Payload for configuring a baker. The different constructors cover the different common cases. The [Default] implementation produces an empty configure that will have no effects."],["ConfigureDelegationPayload","Payload for configuring delegation. The [Default] implementation produces an empty configuration that will not change anything."],["CooldownParameters",""],["EncodedPayload","An account transaction payload that has not yet been deserialized. This is a simple wrapper around Vec with bespoke serialization."],["ExceedsPayloadSize",""],["GASRewards","The reward fractions related to the gas account and inclusion of special transactions."],["HigherLevelAccessStructure","Either root, level1, or level 2 access structure. They all have the same structure, keys and a threshold. The phantom type parameter is used for added type safety to distinguish different access structures in different contexts."],["InitContractPayload","Data needed to initialize a smart contract."],["Memo","A data that was registered on the chain."],["PayloadSize","Type safe wrapper to record the size of the transaction payload."],["PoolParameters","Parameters related to staking pools. This applies to protocol version 4 and up."],["ProtocolUpdate","A generic protocol update. This is essentially an announcement of the update. The details of the update will be communicated in some off-chain way, and bakers will need to update their node software to support the update."],["RegisteredData","A data that was registered on the chain."],["RewardPeriodLength","Length of a reward period in epochs. Must always be a strictly positive integer."],["TimeParameters","The time parameters are introduced as of protocol version 4, and consist of the reward period length and the mint rate per payday. These are coupled as a change to either affects the overall rate of minting."],["TooBig","An error used to signal that an object was too big to be converted."],["TooLargeError","Registered data is too large."],["TransactionFeeDistribution","Update the transaction fee distribution to the specified value."],["TransactionHeader","Header of an account transaction that contains basic data to check whether the sender and the transaction is valid."],["TransactionTypeConversionError","An error that occurs when trying to convert an invalid i32 tag to a [TransactionType]."],["UpdateContractPayload","Data needed to update a smart contract instance."],["UpdateHeader","A header common to all update instructions."],["UpdateInstruction",""],["UpdateInstructionSignature","Signature of an update instruction."]],"trait":[["AuthorizationsFamily","Together with [`Authorizations`] this defines a type family allowing us to map [`ChainParameterVersion0`] and [`ChainParameterVersion1`] to the corresponding `Authorizations` version."],["ExactSizeTransactionSigner","A signing implementation that knows the number of keys up-front."],["HasAccountAccessStructure","Implementations of this trait are structures which can produce public keys with which transaction signatures can be verified."],["PayloadLike","A helper trait so that we can treat payload and encoded payload in the same place."],["TransactionSigner","Abstraction of private keys."],["UpdateSigner","Implementors of this trait can sign update instructions."]],"type":[["Authorizations","A mapping of chain parameter versions to authorization versions."],["BakerAddKeysPayload","Baker keys payload containing proofs construct for a `AddBaker` transaction."],["BakerUpdateKeysPayload","Baker keys payload containing proofs construct for a `UpdateBakerKeys` transaction."],["ConfigureBakerKeysPayload","Baker keys payload containing proofs construct for a `ConfigureBaker` transaction."]]});