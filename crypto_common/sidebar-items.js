initSidebarItems({"constant":[["VERSION_0","Version 0 as a constant for ease of use."]],"derive":[["SerdeDeserialize","Derive macro to derive [serde::Deserialize] instances."],["SerdeSerialize","Derive macro to derive [serde::Serialize] instances."]],"fn":[["base16_decode","Dual to [base16_encode]."],["base16_decode","Dual to [base16_encode]."],["base16_decode_string","Dual to [base16_encode_string]."],["base16_decode_string","Dual to [base16_encode_string]."],["base16_encode","Encode the given value into a byte array using its [Serial] instance, and then encode that byte array as a hex string into the provided serde Serializer."],["base16_encode","Encode the given value into a byte array using its [Serial] instance, and then encode that byte array as a hex string into the provided serde Serializer."],["base16_encode_string","Analogous to [base16_encode], but encodes into a string rather than a serde Serializer."],["base16_encode_string","Analogous to [base16_encode], but encodes into a string rather than a serde Serializer."],["base16_ignore_length_decode","Dual to [base16_ignore_length_encode]"],["base16_ignore_length_decode","Dual to [base16_ignore_length_encode]"],["base16_ignore_length_encode","Analogous to [base16_encode] but after serializing to a byte array it only encodes the `&[4..]` into the serde Serializer. This is intended to use in cases where we are encoding a collection such as a vector into JSON. Since JSON is self-describing we do not need to explicitly record the length, which we do in binary."],["base16_ignore_length_encode","Analogous to [base16_encode] but after serializing to a byte array it only encodes the `&[4..]` into the serde Serializer. This is intended to use in cases where we are encoding a collection such as a vector into JSON. Since JSON is self-describing we do not need to explicitly record the length, which we do in binary."],["deserial_bytes","Read a vector of the given size. NB: Be aware that this allocates a buffer of the given length, and so this must only be used when the size is bounded, otherwise it will lead to a memory allocation failure, and panic."],["deserial_bytes","Read a vector of the given size. NB: Be aware that this allocates a buffer of the given length, and so this must only be used when the size is bounded, otherwise it will lead to a memory allocation failure, and panic."],["deserial_map_no_length","Deserialize a map from a byte source. This ensures there are no duplicates, as well as that all keys are in strictly increasing order."],["deserial_map_no_length","Deserialize a map from a byte source. This ensures there are no duplicates, as well as that all keys are in strictly increasing order."],["deserial_set_no_length","Analogous to [deserial_map_no_length], but for sets. NB: This ensures there are no duplicates, and that all the keys are in strictly increasing order."],["deserial_set_no_length","Analogous to [deserial_map_no_length], but for sets. NB: This ensures there are no duplicates, and that all the keys are in strictly increasing order."],["deserial_string","Read a string of given size. NB: Be aware that this allocates a buffer of the given length, and so this must only be used when the size is bounded, otherwise it will lead to a memory allocation failure, and panic."],["deserial_string","Read a string of given size. NB: Be aware that this allocates a buffer of the given length, and so this must only be used when the size is bounded, otherwise it will lead to a memory allocation failure, and panic."],["deserial_vector_no_length","Read a vector of a given size. This protects against excessive memory allocation by only pre-allocating a maximum safe size."],["deserial_vector_no_length","Read a vector of a given size. This protects against excessive memory allocation by only pre-allocating a maximum safe size."],["from_bytes","A small wrapper that is sometimes more convenient than `A::deserial`. It is here mostly for historical reasons, for backwards compatibility."],["from_bytes","A small wrapper that is sometimes more convenient than `A::deserial`. It is here mostly for historical reasons, for backwards compatibility."],["safe_with_capacity","As Vec::with_capacity, but only allocate maximum MAX_PREALLOCATED_CAPACITY elements."],["safe_with_capacity","As Vec::with_capacity, but only allocate maximum MAX_PREALLOCATED_CAPACITY elements."],["serial_iter","Serialize all of the elements in the iterator."],["serial_iter","Serialize all of the elements in the iterator."],["serial_map_no_length","Serialize an ordered map. Serialization is by increasing order of keys."],["serial_map_no_length","Serialize an ordered map. Serialization is by increasing order of keys."],["serial_set_no_length","Analogous to [serial_map_no_length], but for sets."],["serial_set_no_length","Analogous to [serial_map_no_length], but for sets."],["serial_string","Write a string directly to the provided sink (without encoding its length). The string is utf8 encoded."],["serial_string","Write a string directly to the provided sink (without encoding its length). The string is utf8 encoded."],["serial_vector_no_length","Write an array without including length information."],["serial_vector_no_length","Write an array without including length information."],["serialize_deserialize","A simple function that serializes and then immediately deserializes a value. This should always return Ok(v) where `v` is equivalent to the given argument. Used for testing."],["to_bytes","Directly serialize to a vector of bytes."],["to_bytes","Directly serialize to a vector of bytes."]],"mod":[["encryption","Module that provides a simple API for symmetric encryption in the output formats used by Concordium."],["types","Common types needed in concordium."]],"struct":[["Version","Version of the serialization of a data structure. Binary coded as a variable integer represented by bytes, where MSB=1 indicates more bytes follow, and the 7 lower bits in a byte is Big Endian data bits for the value. A version number is bounded by u32 max."],["Versioned","Versioned represents T as a versioned data-structure. The version is a integer number up to the implementation, which is serialized using variable integer encoding. The caller is responsible for ensuring the data structure `T` is compatible with the version number."]],"trait":[["Buffer","Trait for writers which will not fail in normal operation with small amounts of data, e.g., Vec. Moreover having a special trait allows us to implement it for other types, such as the SHA Digest."],["Buffer","Trait for writers which will not fail in normal operation with small amounts of data, e.g., Vec. Moreover having a special trait allows us to implement it for other types, such as the SHA Digest."],["Deserial","Trait for types which can be recovered from byte sources."],["Deserial","Trait for types which can be recovered from byte sources."],["Get","Analogue of [Deserial], but instead this has the type to serialize as a type parameter, and is implemented once for a source. The reason for this trait is that it is often more convenient to use since we can rely on the typechecker to fill in more details. Contrast `A::deserial(source)` to `source.get()`. In the latter case the return type is usually clear from context."],["Get","Analogue of [Deserial], but instead this has the type to serialize as a type parameter, and is implemented once for a source. The reason for this trait is that it is often more convenient to use since we can rely on the typechecker to fill in more details. Contrast `A::deserial(source)` to `source.get()`. In the latter case the return type is usually clear from context."],["Put","Dual to `Get`, and the analogue of `Serial`. It allows writing `sink.put(value)` in contrast to `value.serial(sink)`. It is less important than `Get`."],["Put","Dual to `Get`, and the analogue of `Serial`. It allows writing `sink.put(value)` in contrast to `value.serial(sink)`. It is less important than `Get`."],["ReadBytesExt","Extends `Read` with methods for reading numbers. (For `std::io`.)"],["SerdeDeserialize","Derive macro to derive [serde::Deserialize] instances."],["SerdeSerialize","Derive macro to derive [serde::Serialize] instances."],["Serial","Trait implemented by types which can be encoded into byte arrays. The intention is that the encoding is binary and not human readable."],["Serial","Trait implemented by types which can be encoded into byte arrays. The intention is that the encoding is binary and not human readable."],["Serialize","A convenient way to refer to both [Serial] and [Deserial] together."],["Serialize","A convenient way to refer to both [Serial] and [Deserial] together."],["WriteBytesExt","Extends `Write` with methods for writing numbers. (For `std::io`.)"]],"type":[["ParseResult","Result when deserializing a value. This is a simple wrapper around `Result` that fixes the error type to be [anyhow::Error]."],["ParseResult","Result when deserializing a value. This is a simple wrapper around `Result` that fixes the error type to be [anyhow::Error]."]]});