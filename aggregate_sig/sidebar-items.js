initSidebarItems({"constant":[["PUBLIC_KEY_SIZE","Size of the aggregate signature public key in bytes."],["SECRET_KEY_SIZE","Size of the aggregate signature secret key in bytes."],["SIGNATURE_SIZE","Size of the aggregate signature in bytes."]],"fn":[["verify_aggregate_sig","Verifies an aggregate signature on pairs `(messages m_i, PK_i)` `for i=1..n` by checking     `pairing(sig, g_2) == product_{i=0}^n ( pairing(g1_hash(m_i), PK_i) )` where `g_2` is the generator of G2. Verification returns false if any two messages are not distinct"],["verify_aggregate_sig_hybrid","Verifies an aggregate signature on pairs `(messages m_i, set_i)` `for i=1..n` but where `set_i` denotes the set of public keys corresponding to the secret keys that signed m_i. This implements a combination of AggregateVerify from Section 3.1.1 and FastAggregateVerify from Section 3.3.4 of https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-bls-signature-05#section-3.1.1."],["verify_aggregate_sig_trusted_keys","Verifies an aggregate signature on the same message m under keys PK_i for i=1..n by checking     pairing(sig, g_2) == pairing(g1_hash(m), sum_{i=0}^n (PK_i)) where g_2 is the generator of G2."]],"struct":[["PublicKey","A Public Key is a point on the second curve of the pairing"],["SecretKey","A Secret Key is a scalar in the scalarfield of the pairing."],["Signature",""]],"type":[["Proof","A proof of knowledge of a secretkey"]]});