initSidebarItems({"constant":[["BINOP","Base cost of a binary instruction."],["BOUNDS","Cost of a bounds check in, for example, BrTable, and memory loads and stores."],["BR_IF","BR_IF is almost the same as an IF statement, so we price it the same."],["CONST","Cost of a `const` instruction."],["DIV",""],["DROP","Parametric instructions"],["FUNC_FRAME_BASE","Part of a cost of a function call related to allocating a new function frame and storing values of locals, etc."],["GET_GLOBAL","Looking up globals is cheap compared to linear memory. They are essentially the same as locals, except they are in a different array."],["GET_LOCAL","Local variable instructions are cheap. We treat them as stack operations."],["IF_STATEMENT","The if statement boils down to a test and a jump afterwards. Jumps are simply setting the instruction pointer."],["JUMP","Cost of a jump (either Br, Loop, or analogous)."],["LOAD_WORD","Memory instructions."],["MEMGROW","Constant part for the memory grow instruction. The variable part is charged for by the host function."],["MEMSIZE","Checking memory size is pretty cheap, it is just a vec.len() call."],["MUL","See for example https://streamhpc.com/blog/2012-07-16/how-expensive-is-an-operation-on-a-cpu/ The cost of `MUL`, `DIV` and `REM` is in general more, so we account for that. However the ratio compared to add is not that much more since our current implementation is an interpreter, and consequently there are overheads in argument handling that dominate the costs."],["NOP","Control instructions"],["REM",""],["SELECT",""],["SET_GLOBAL",""],["SET_LOCAL",""],["SIMPLE_BINOP","Cost of a simple binary instruction. This includes all bit operations, and addition and subtraction."],["SIMPLE_UNOP","Cost of a simple unary instruction. Which at present contains all unary numeric instructions."],["TEE_LOCAL",""],["TEST","Cost of a boolean test."],["UNOP","Numeric instructions"]],"fn":[["br_table","Cost of a branch with table (switch statement). This involves bounds checking on the array of labels, and then a normal branch."],["branch","Cost of an unconditional jump with the given label arity. The label arity for us is either 0 or 1, since we do not support multiple return values."],["call_indirect","Cost of call_indirect with the given number of arguments and results. This is expensive since it involves a dynamic type check."],["copy_stack","Copy n elements from one place in the stack to another. Used by jumps and function returns."],["get_cost","Get the cost of the given instruction in the context of the stack of labels, and the module."],["invoke_after","Cost incurred by the number of locals when invoking a function (to be charged after invocation). The number of locals is only the number of declared locals, not including function parameters."],["invoke_before","Cost for invoking a function before the entering the function. This excludes the cost incurred by the number of locals the function defines (for the latter, see `invoke_after`)."],["read_stack","Read n elements from the stack."],["store","Store n bytes in linear memory."],["type_check","Cost of a dynamic type check. The argument is the number of types i.e., parameters + results that need to be checked."],["write_stack","Write n elements to the stack."]],"type":[["Energy",""]]});