initSidebarItems({"fn":[["commitment_to_share","Given a list of commitments g^{a_i}h^{r_i} and a point x (the share number), compute g^p(x)h^r(x) where p(x) = a_0 + a_1 x + … + a_n x^n r(x) = r_0 + r_1 x + … + r_n x^n"],["credential_hash_to_sign","Compute the hash of the credential deployment that should be signed by the account keys for deployment. If `new_or_existing` is `Left` then this credential will create a new account, and the transaction expiry should be signed. otherwise it is going to be deployed to the given account address, and the address should be signed."],["encode_ars","Encode anonymity revokers into a list of scalars. The encoding is as follows. Given a list of identity providers, and a capacity C, we encode it into multiple scalars, in big-endian representation. The encodings are shifted, and the last (least significant) bit of the scalar encodes whether there are more scalars to follow. That is the case if and only if the bit is 1. The field must be big enough to encode u64."],["encode_public_credential_values","Encode two yearmonth values into a scalar. This encodes them after converting them into u32, first putting created_at, and then valid_to into the scalar. Thus create_at starts at the least-significant bit. The threshold is stored in the next byte."],["encode_tags","Encode attribute tags into a big-integer bits. The tags are encoded from least significant bit up, i.e., LSB of the result is set IFF tag0 is in the list. This function will fail if"],["encrypt_prf_share","This function is used for encryption of the PRF key share in chunks, where the chunks are written in little endian. The arguments are"],["evaluate_poly","Interpret the array as coefficients of a polynomial starting at 0, and evaluate the polynomial at the given point."],["merge_iter","Given two ordered iterators call the corresponding functions in the increasing order of keys. That is, essentially merge the two iterators into an ordered iterator and then map, but this is all done inline."],["verify_account_ownership_proof","This function verifies that the signature inside the AccountOwnershipProof is a signature of the given message. The arguments are"]]});