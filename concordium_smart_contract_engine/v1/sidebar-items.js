initSidebarItems({"enum":[["InitResult","Result of execution of the contract’s init function."],["Interrupt","Interrupt triggered by the smart contract to execute an instruction on the host, either an account transfer, a smart contract call or an upgrade instruction."],["InvokeFailure","The kind of errors that may occur during handling of contract `invoke` or `upgrade`."],["InvokeResponse","Response from an invoke call."],["ReceiveResult","Result of execution of a receive function."]],"fn":[["invoke_init","Invokes an init-function from a given artifact"],["invoke_init_from_artifact","Invokes an init-function from a given serialized artifact."],["invoke_init_from_source","Invokes an init-function from a serialized Wasm module."],["invoke_init_with_metering_from_source","Same as `invoke_init_from_source`, except that the module has cost accounting instructions inserted before the init function is called."],["invoke_receive","Invokes a receive-function from a given artifact."],["invoke_receive_from_artifact","Invokes a receive-function from a given serialized artifact."],["invoke_receive_from_source","Invokes a receive-function from a given serialized Wasm module."],["invoke_receive_with_metering_from_source","Invokes a receive-function from a given serialized Wasm module. Before execution the Wasm module is injected with cost metering."],["resume_receive","Resume execution of the receive method after handling the interrupt."]],"mod":[["trie","Implementation of the contract state trie that is exposed as a key-value store to smart contracts."]],"struct":[["ConcordiumAllowedImports","Allowed imports for V1 modules. Whether some imports are allowed depends on the protocol version that is used to validate the module."],["InitInvocation","Collection of information relevant to invoke a init-function."],["InstanceState","The runtime representation of the contract state. This collects all the pieces of data needed to efficiently use the state."],["InstanceStateEntry","first bit is ignored, the next 31 indicate a generation, the final 32 indicates an index in the entry_mapping."],["InvokeFromArtifactCtx","Common data used by the `invoke_*_from_artifact` family of functions."],["InvokeFromSourceCtx","Common data used by the `invoke_*_from_source` family of functions."],["ProcessedImports","Imports allowed for `v1` contracts processed into a format that is faster to use during execution. Instead of keeping names of imports they are processed into an enum with integer tags."],["ReceiveContext","Chain context accessible to receive methods of V1 contracts."],["ReceiveInvocation","Collection of information relevant to invoke a receive-function."],["ReceiveParams","Runtime parameters that affect the limits placed on the entrypoint execution."],["SavedHost","Host that is saved between handling of operations. This contains sufficient information to resume execution once control returns to the contract."]],"trait":[["HasReceiveContext","A receive context for V1 contracts."]],"type":[["InstanceCounter","A counter of the “state instance”. When contract execution is interrupted and then resumed, if the state has been modified by the handling of the operation then all state entries that were handed out before the interrupt are invalidated. This is achieved by incrementing the instance counter."],["ParameterRef","Parameter whose ownership is tracked statically."],["ParameterVec","Parameter whose ownership is tracked dynamically. This is needed, for example, when execution passes through Haskell and Rust. Ideally this would be Arc<[u8]> but then this cannot be passed via the FFI boundary directly since [u8] is not Sized. To avoid a third type we settle on Vec."],["ReceiveInterruptedState","State of the suspended execution of the receive function. This retains both the module that is executed, as well the host."],["ReturnValue",""],["StateResult",""]]});