initSidebarItems({"enum":[["ChunkSize","Possible chunk sizes in bits."]],"fn":[["chunks_to_value","NB: This function does not ensure there is no overflow. It assumes that the chunks are reasonable and at most 64 bits."],["decrypt_from_chunks","Wrapper around `decrypt_from_chunks_given_generator` that uses the generator that is part of the key."],["decrypt_from_chunks_given_generator",""],["decrypt_from_chunks_given_table",""],["encrypt_in_chunks","Wrapper around `encrypt_in_chunks_given_generator` that uses the generator that is part of the public key."],["encrypt_in_chunks_given_generator",""],["encrypt_u64_in_chunks_given_generator","Encrypt a single `u64` value in chunks in the exponent of the given generator."],["multicombine","Perform a “linear combination in the exponent”, i.e., multiply each of the ciphers with the corresponding scalar, and sum them together. If cipher C_i ciphers is an encryption in the exponent of the value v_i, then the resulting cipher is a valid encryption in the exponent of the value \\sum_i v_i \\cdot s_i where s_i is the i-th scalar."],["value_to_chunks","Transform a scalar into as many chunks as necessary. The chunks are returned in little-endian order."]],"struct":[["BabyStepGiantStep","The table for the baby step giant step algorithm, with some auxiliary data."],["Cipher","Encrypted message."],["Message","Message to be encrypted. This is a simple wrapper around a group element, but we use it for added type safety."],["PublicKey","Elgamal public key ."],["Randomness","Randomness which was used to encrypt a message."],["SecretKey","Elgamal secret key packed together with a chosen generator."]],"type":[["BabyStepGiantStepTable",""]]});